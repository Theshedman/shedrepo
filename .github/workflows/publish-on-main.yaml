name: Publish repo (build AUR from manifest, gen DB, upload)

on:
  push:
    branches: ["main"]

permissions:
  contents: read
  id-token: write

env:
  ARCH: x86_64
  REPO_OUT: output/repo
  ARTIFACT_OUT: output/artifacts

jobs:
  build-and-publish:
    runs-on: ubuntu-latest
    env:
      GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Prepare paths
        run: |
          mkdir -p "${GITHUB_WORKSPACE}/${REPO_OUT}/${ARCH}"
          mkdir -p "${GITHUB_WORKSPACE}/${ARTIFACT_OUT}"
          ls -la packages/aur || true

      - name: Import GPG private key (host for repo signing)
        if: ${{ env.GPG_PRIVATE_KEY != '' }}
        run: |
          echo "${{ env.GPG_PRIVATE_KEY }}" > /tmp/gpg_private.asc
          gpg --batch --import /tmp/gpg_private.asc || true
          shred -u /tmp/gpg_private.asc || rm -f /tmp/gpg_private.asc
          gpg --list-secret-keys --keyid-format LONG
        shell: bash

      - name: Install Docker (if needed) and rclone
        run: |
          set -euo pipefail
          if command -v docker >/dev/null 2>&1; then
            echo "docker already installed: $(docker --version)"
          else
            echo "Installing docker using official convenience script"
            curl -fsSL https://get.docker.com | sudo sh
            sudo usermod -aG docker $USER || true
          fi

          if command -v rclone >/dev/null 2>&1; then
            echo "rclone already installed: $(rclone --version)"
          else
            echo "Installing rclone"
            curl -fsSL https://rclone.org/install.sh | sudo bash
          fi
        shell: bash

      - name: Ensure scripts are executable
        run: |
          chmod +x scripts/build-aur.sh || true
          chmod +x shedrepo/commands/*.sh || true
        shell: bash

      - name: Build AUR packages from manifest (serial, non-root inside container)
        env:
          ARCH: ${{ env.ARCH }}
        run: |
          set -euo pipefail
          ART_DIR="${GITHUB_WORKSPACE}/${ARTIFACT_OUT}"

          while IFS= read -r pkg || [ -n "$pkg" ]; do
            pkg="$(echo "$pkg" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"
            [[ -z "$pkg" ]] && continue
            echo "==> Building package: $pkg"

            docker run --rm -v "${GITHUB_WORKSPACE}:/workspace" -w "/workspace" \
              --env "ARCH=${ARCH}" --env "PKG=${pkg}" archlinux:latest /bin/bash -lc "
                
                set -euo pipefail

                # create builder early
                useradd -m -s /bin/bash builder || true
                chown -R builder:builder /workspace || true

                # init pacman keyring
                pacman-key --init
                pacman-key --populate archlinux

                # update & install base build deps
                pacman -Sy --noconfirm archlinux-keyring || true
                pacman -Syu --noconfirm || true
                pacman -Sy --noconfirm --needed base-devel git fakeroot gnupg curl pacman-contrib

                # clone AUR package into tmpdir (prefer canonical path)
                AUR_TMP_DIR=\$(mktemp -d /tmp/aurbuild.XXXXXX)
                git clone --depth 1 \"https://aur.archlinux.org/packages/\${PKG}.git\" \"\${AUR_TMP_DIR}\" 2>/dev/null || \
                  git clone --depth 1 \"https://aur.archlinux.org/\${PKG}.git\" \"\${AUR_TMP_DIR}\"

                if [[ ! -d \"\${AUR_TMP_DIR}\" ]]; then
                  echo \"[ERROR] Failed to clone AUR package: \${PKG}\" >&2
                  exit 3
                fi

                # read PKGBUILD to extract both depends and makedepends
                cd \"\${AUR_TMP_DIR}\"
                
                echo \"[DEBUG] Extracting dependencies from PKGBUILD...\"
                
                # Extract depends using awk (handles multi-line arrays)
                depends_raw=\"\"
                depends_raw=\$(awk '/^depends=\\(/,/)/ {print}' PKGBUILD | sed 's/depends=(//; s/).*//; s/[\\047\"]//g' | tr '\\n' ' ' | xargs)
                echo \"[DEBUG] Extracted depends: \${depends_raw}\"
                
                # Extract makedepends using awk (handles multi-line arrays)
                makedeps_raw=\"\"
                makedeps_raw=\$(awk '/^makedepends=\\(/,/)/ {print}' PKGBUILD | sed 's/makedepends=(//; s/).*//; s/[\\047\"]//g' | tr '\\n' ' ' | xargs)
                echo \"[DEBUG] Extracted makedepends: \${makedeps_raw}\"
                
                # Extract validpgpkeys for GPG signature verification
                validpgpkeys_raw=\"\"
                validpgpkeys_raw=\$(awk '/^validpgpkeys=\\(/,/)/ {print}' PKGBUILD 2>/dev/null | sed 's/validpgpkeys=(//; s/).*//; s/[\\047\"]//g' | tr '\\n' ' ' | xargs || true)
                echo \"[DEBUG] Extracted validpgpkeys: '\${validpgpkeys_raw}'\"
                
                # Also try single-line format
                if [[ -z \"\${validpgpkeys_raw}\" ]]; then
                  validpgpkeys_raw=\$(grep -oP 'validpgpkeys=\\(\\K[^)]+' PKGBUILD 2>/dev/null | sed 's/[\\047\"]//g' | xargs || true)
                  echo \"[DEBUG] Single-line extraction result: '\${validpgpkeys_raw}'\"
                fi
                
                if [[ -n \"\${validpgpkeys_raw// }\" ]]; then
                  echo \"[INFO] Found GPG keys to import: \${validpgpkeys_raw}\"
                  for key in \${validpgpkeys_raw}; do
                    echo \"[INFO] Importing GPG key as root: \${key}\"
                    gpg --batch --keyserver keyserver.ubuntu.com --recv-keys \"\${key}\" 2>&1 | head -5 || \
                      gpg --batch --keyserver keys.openpgp.org --recv-keys \"\${key}\" 2>&1 | head -5 || \
                      gpg --batch --keyserver pgp.mit.edu --recv-keys \"\${key}\" 2>&1 | head -5 || \
                      echo \"[WARN] Could not import key \${key} from any keyserver\"
                    
                    # Also import for builder user
                    echo \"[INFO] Importing GPG key for builder user: \${key}\"
                    su -s /bin/bash builder -c \"gpg --batch --keyserver keyserver.ubuntu.com --recv-keys '\${key}'\" 2>&1 | head -5 || \
                      su -s /bin/bash builder -c \"gpg --batch --keyserver keys.openpgp.org --recv-keys '\${key}'\" 2>&1 | head -5 || \
                      su -s /bin/bash builder -c \"gpg --batch --keyserver pgp.mit.edu --recv-keys '\${key}'\" 2>&1 | head -5 || \
                      echo \"[WARN] Could not import key \${key} for builder user\"
                  done
                else
                  echo \"[INFO] No GPG keys found in PKGBUILD\"
                fi
                
                # Combine both dependency lists
                all_deps_raw=\"\${depends_raw} \${makedeps_raw}\"
                echo \"[DEBUG] Combined dependencies: \${all_deps_raw}\"

                # sanitize tokens: split, remove quotes/backticks, strip version constraints
                deps_list=()
                if [[ -n \"\${all_deps_raw// }\" ]]; then
                  # split into words safely
                  read -ra _tokens <<< \"\$(echo \"\${all_deps_raw}\" | tr '\\n' ' ' | tr -s ' ' ' ')\"
                  for tok in \"\${_tokens[@]}\"; do
                    # remove surrounding quotes/backticks
                    tok=\${tok//\\\"/}
                    tok=\${tok//\\'/}
                    tok=\${tok//\\\`/}
                    # strip version constraints: remove everything from first <, >, =, or :
                    tok=\${tok%%[<>=:]*}
                    # ignore empty
                    if [[ -n \"\$tok\" ]]; then
                      deps_list+=(\"\$tok\")
                    fi
                  done
                fi

                # deduplicate
                if [[ \${#deps_list[@]} -gt 0 ]]; then
                  # unique-preserve order
                  declare -A seen=()
                  uniq_list=()
                  for p in \"\${deps_list[@]}\"; do
                    if [[ -z \"\${seen[\$p]+_}\" ]]; then
                      uniq_list+=(\"\$p\")
                      seen[\$p]=1
                    fi
                  done
                  deps_list=(\"\${uniq_list[@]}\")
                fi

                # install all dependencies as root (non-interactive) if any
                if [[ \${#deps_list[@]} -gt 0 ]]; then
                  echo \"[INFO] Dependencies detected for \${PKG}: \${deps_list[*]}\"
                  
                  # Sync package database first
                  echo \"[INFO] Syncing package database...\"
                  pacman -Sy --noconfirm
                  
                  # Try to install all at once first (faster)
                  echo \"[INFO] Installing dependencies...\"
                  if pacman -S --noconfirm --needed --asdeps \"\${deps_list[@]}\"; then
                    echo \"[INFO] Pacman install command completed\"
                    
                    # Verify installations
                    echo \"[INFO] Verifying installed packages...\"
                    missing=()
                    for dep in \"\${deps_list[@]}\"; do
                      if pacman -Q \"\$dep\" &>/dev/null; then
                        echo \"  [✓] \$dep\"
                      else
                        echo \"  [✗] \$dep - NOT FOUND\"
                        missing+=(\"\$dep\")
                      fi
                    done
                    
                    if [[ \${#missing[@]} -gt 0 ]]; then
                      echo \"[WARN] These packages are not installed: \${missing[*]}\"
                      echo \"[INFO] They may not exist in official repos or have different names\"
                    else
                      echo \"[INFO] All dependencies verified successfully\"
                    fi
                  else
                    echo \"[ERROR] Pacman install failed, attempting individual install...\"
                    for dep in \"\${deps_list[@]}\"; do
                      if pacman -S --noconfirm --needed --asdeps \"\$dep\"; then
                        echo \"  [✓] Installed: \$dep\"
                      else
                        echo \"  [✗] Failed: \$dep\"
                      fi
                    done
                  fi
                else
                  echo \"[INFO] No dependencies detected for \${PKG}\"
                fi

                # IMPORTANT: cd out before moving the temp dir to avoid getcwd errors
                cd /workspace

                # move cloned source into workspace and set ownership for builder
                BUILD_SRC_DIR=\"/workspace/.aur_src_\${PKG}\"
                rm -rf \"\${BUILD_SRC_DIR}\" || true
                mv \"\${AUR_TMP_DIR}\" \"\${BUILD_SRC_DIR}\"
                chown -R builder:builder \"\${BUILD_SRC_DIR}\"

                # ensure build script is executable (mounts may change perms)
                chmod +x /workspace/scripts/build-aur.sh || true

                # run the build as non-root builder using the local PKGBUILD dir
                su -s /bin/bash builder -c \"
                  cd /workspace
                  /workspace/scripts/build-aur.sh '\${BUILD_SRC_DIR}' '/workspace/${ARTIFACT_OUT}'
                \"

                # done inside container
              "
          done < packages/aur/manifest.txt

          echo "[INFO] Build loop completed"
        shell: bash

      - name: Show artifacts
        run: |
          echo "Artifacts dir listing:"
          find "${GITHUB_WORKSPACE}/${ARTIFACT_OUT}" -maxdepth 3 -ls || true
        shell: bash

      - name: Move artifacts into repo output dir
        run: |
          mkdir -p "${GITHUB_WORKSPACE}/${REPO_OUT}/${ARCH}"
          find "${GITHUB_WORKSPACE}/${ARTIFACT_OUT}" -type f -name '*.pkg.*' -exec cp -v {} "${GITHUB_WORKSPACE}/${REPO_OUT}/${ARCH}/" \;
          find "${GITHUB_WORKSPACE}/${ARTIFACT_OUT}" -type f -name '*.pkg.*.sig' -exec cp -v {} "${GITHUB_WORKSPACE}/${REPO_OUT}/${ARCH}/" \; || true
          ls -la "${GITHUB_WORKSPACE}/${REPO_OUT}/${ARCH}" || true
        shell: bash

      - name: Set REPO_ROOT env for gen_db
        run: |
          echo "REPO_ROOT=${GITHUB_WORKSPACE}/${REPO_OUT}" >> $GITHUB_ENV
          echo "ARCH=${ARCH}" >> $GITHUB_ENV
        shell: bash

      - name: Regenerate DB (gen_db.sh)
        run: |
          ./shedrepo/shedrepo/commands/gen_db.sh
        shell: bash

      - name: Configure rclone remote for R2
        run: |
          RCLONE_REMOTE="${{ secrets.RCLONE_REMOTE_NAME && secrets.RCLONE_REMOTE_NAME || 'r2' }}"
          R2_ENDPOINT="https://${{ secrets.R2_ACCOUNT_ID }}.r2.cloudflarestorage.com"
          rclone config create "${RCLONE_REMOTE}" s3 \
            env_auth false \
            access_key_id "${{ secrets.R2_ACCESS_KEY_ID }}" \
            secret_access_key "${{ secrets.R2_SECRET_ACCESS_KEY }}" \
            endpoint "${R2_ENDPOINT}" \
            region auto
          echo "rclone remote '${RCLONE_REMOTE}' configured"
        shell: bash

      - name: Upload repo to R2
        run: |
          RCLONE_REMOTE="${{ secrets.RCLONE_REMOTE_NAME && secrets.RCLONE_REMOTE_NAME || 'r2' }}"
          TARGET="${RCLONE_REMOTE}:${{ secrets.R2_BUCKET }}/${ARCH}/"
          rclone sync --progress --create-empty-src-dirs --delete-after "${GITHUB_WORKSPACE}/${REPO_OUT}/${ARCH}/" "${TARGET}"
          echo "Upload finished."
        shell: bash

      - name: Cleanup rclone remote
        if: always()
        run: |
          rclone config delete "${{ secrets.RCLONE_REMOTE_NAME && secrets.RCLONE_REMOTE_NAME || 'r2' }}" || true
        shell: bash