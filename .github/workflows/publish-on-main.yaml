name: Publish repo (build AUR from manifest, gen DB, upload)

on:
  push:
    branches: ["main"]

permissions:
  contents: read
  id-token: write

env:
  ARCH: x86_64
  REPO_OUT: output/repo
  ARTIFACT_OUT: output/artifacts

jobs:
  build-and-publish:
    runs-on: ubuntu-latest
    env:
      GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Prepare paths
        run: |
          mkdir -p "${GITHUB_WORKSPACE}/${REPO_OUT}/${ARCH}"
          mkdir -p "${GITHUB_WORKSPACE}/${ARTIFACT_OUT}"
          ls -la packages/aur || true

      - name: Import GPG private key (host for repo signing)
        if: ${{ env.GPG_PRIVATE_KEY != '' }}
        run: |
          echo "${{ env.GPG_PRIVATE_KEY }}" > /tmp/gpg_private.asc
          gpg --batch --import /tmp/gpg_private.asc || true
          shred -u /tmp/gpg_private.asc || rm -f /tmp/gpg_private.asc
          gpg --list-secret-keys --keyid-format LONG
        shell: bash

      - name: Install Docker (if needed) and rclone
        run: |
          set -euo pipefail
          if command -v docker >/dev/null 2>&1; then
            echo "docker already installed: $(docker --version)"
          else
            echo "Installing docker using official convenience script"
            curl -fsSL https://get.docker.com | sudo sh
            sudo usermod -aG docker $USER || true
          fi

          if command -v rclone >/dev/null 2>&1; then
            echo "rclone already installed: $(rclone --version)"
          else
            echo "Installing rclone"
            curl -fsSL https://rclone.org/install.sh | sudo bash
          fi
        shell: bash

      - name: Ensure scripts are executable
        run: |
          chmod +x scripts/build-aur.sh || true
          chmod +x shedrepo/commands/*.sh || true
        shell: bash

      - name: Build AUR packages from manifest (serial, non-root inside container)
        env:
          ARCH: ${{ env.ARCH }}
        run: |
          set -euo pipefail
          ART_DIR="${GITHUB_WORKSPACE}/${ARTIFACT_OUT}"

          while IFS= read -r pkg || [ -n "$pkg" ]; do
            pkg="$(echo "$pkg" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"
            [[ -z "$pkg" ]] && continue
            echo "==> Building package: $pkg"

            docker run --rm -v "${GITHUB_WORKSPACE}:/workspace" -w "/workspace" \
              --env "ARCH=${ARCH}" archlinux:latest /bin/bash -lc "
                set -euo pipefail

                # 1) Create non-root builder before pacman operations
                useradd -m -s /bin/bash builder || true
                chown -R builder:builder /workspace || true

                # 2) Init & populate pacman keyring BEFORE upgrading packages
                pacman-key --init
                pacman-key --populate archlinux

                # 3) Update keyring and install base-devel & helpers
                pacman -Sy --noconfirm archlinux-keyring || true
                pacman -Syu --noconfirm || true
                pacman -Sy --noconfirm --needed base-devel git fakeroot gnupg curl pacman-contrib

                # 4) Prepare a temp clone of the AUR package so we can install makedepends as root
                TMPDIR=\$(mktemp -d /tmp/aurbuild.XXXXXX)
                # prefer canonical packages/<pkg>.git path; fallback to short form
                git clone --depth 1 \"https://aur.archlinux.org/packages/${pkg}.git\" \"\${TMPDIR}\" 2>/dev/null || \
                  git clone --depth 1 \"https://aur.archlinux.org/${pkg}.git\" \"\${TMPDIR}\"

                if [[ ! -d \"\${TMPDIR}\" ]]; then
                  echo \"[ERROR] Failed to clone AUR package: ${pkg}\" >&2
                  exit 3
                fi

                cd \"\${TMPDIR}\"

                # 5) Extract simple makedepends array from PKGBUILD (common case)
                makedeps=''
                if [[ -f PKGBUILD ]]; then
                  makedeps=$(awk '
                    BEGIN { capture=0; deps="" }
                    /makedepends[[:space:]]*=.*\(/ { capture=1; sub(/.*\(/, ""); line=$0 }
                    capture && /\)/ { sub(/\).*/, ""); deps = deps " " line; capture=0 }
                    capture { deps = deps " " \$0 }
                    END {
                      gsub(/[^[:alnum:]_\-:\/.]/, " ", deps);
                      gsub(/[[:space:]]+/, " ", deps);
                      gsub(/^[[:space:]]+|[[:space:]]+$/, "", deps);
                      print deps
                    }' PKGBUILD)

                  if [[ -z \"\${makedeps}\" ]]; then
                    makedeps=\$(grep -oP '(?<=makedepends=\\().*(?=\\))' PKGBUILD 2>/dev/null | tr -d '\"' | tr '\\n' ' ' || true)
                  fi
                fi

                # 6) Install makedepends as root if any (non-interactive)
                if [[ -n \"\${makedeps// }\" ]]; then
                  echo \"[INFO] Installing makedepends for ${pkg}: \${makedeps}\"
                  read -r -a deps_array <<< \"\${makedeps}\"
                  pacman -Sy --noconfirm --needed \"\${deps_array[@]}\" || true
                else
                  echo \"[INFO] No makedepends detected for ${pkg}\"
                fi

                # 7) Move cloned source to a stable path inside workspace and change ownership
                BUILD_SRC_DIR=\"/workspace/.aur_src_${pkg}\"
                rm -rf \"\${BUILD_SRC_DIR}\" || true
                mv \"\${TMPDIR}\" \"\${BUILD_SRC_DIR}\"
                chown -R builder:builder \"\${BUILD_SRC_DIR}\"

                # 8) Run the build script as non-root builder; pass local PKGBUILD dir to avoid re-clone
                su -s /bin/bash builder -c \"
                  cd /workspace
                  /workspace/scripts/build-aur.sh '\${BUILD_SRC_DIR}' '/workspace/${ARTIFACT_OUT}'
                \"

                # done inside container
              "
          done < packages/aur/manifest.txt

          echo "[INFO] Build loop completed"
        shell: bash

      - name: Show artifacts
        run: |
          echo "Artifacts dir listing:"
          find "${GITHUB_WORKSPACE}/${ARTIFACT_OUT}" -maxdepth 3 -ls || true
        shell: bash

      - name: Move artifacts into repo output dir
        run: |
          mkdir -p "${GITHUB_WORKSPACE}/${REPO_OUT}/${ARCH}"
          find "${GITHUB_WORKSPACE}/${ARTIFACT_OUT}" -type f -name '*.pkg.*' -exec cp -v {} "${GITHUB_WORKSPACE}/${REPO_OUT}/${ARCH}/" \;
          find "${GITHUB_WORKSPACE}/${ARTIFACT_OUT}" -type f -name '*.pkg.*.sig' -exec cp -v {} "${GITHUB_WORKSPACE}/${REPO_OUT}/${ARCH}/" \; || true
          ls -la "${GITHUB_WORKSPACE}/${REPO_OUT}/${ARCH}" || true
        shell: bash

      - name: Set REPO_ROOT env for gen_db
        run: |
          echo "REPO_ROOT=${GITHUB_WORKSPACE}/${REPO_OUT}" >> $GITHUB_ENV
          echo "ARCH=${ARCH}" >> $GITHUB_ENV
        shell: bash

      - name: Regenerate DB (gen_db.sh)
        run: |
          ./shedrepo/shedrepo/commands/gen_db.sh
        shell: bash

      - name: Configure rclone remote for R2
        run: |
          RCLONE_REMOTE="${{ secrets.RCLONE_REMOTE_NAME && secrets.RCLONE_REMOTE_NAME || 'r2' }}"
          R2_ENDPOINT="https://${{ secrets.R2_ACCOUNT_ID }}.r2.cloudflarestorage.com"
          rclone config create "${RCLONE_REMOTE}" s3 \
            env_auth false \
            access_key_id "${{ secrets.R2_ACCESS_KEY_ID }}" \
            secret_access_key "${{ secrets.R2_SECRET_ACCESS_KEY }}" \
            endpoint "${R2_ENDPOINT}" \
            region auto
          echo "rclone remote '${RCLONE_REMOTE}' configured"
        shell: bash

      - name: Upload repo to R2
        run: |
          RCLONE_REMOTE="${{ secrets.RCLONE_REMOTE_NAME && secrets.RCLONE_REMOTE_NAME || 'r2' }}"
          TARGET="${RCLONE_REMOTE}:${{ secrets.R2_BUCKET }}/${ARCH}/"
          rclone sync --progress --create-empty-src-dirs --delete-after "${GITHUB_WORKSPACE}/${REPO_OUT}/${ARCH}/" "${TARGET}"
          echo "Upload finished."
        shell: bash

      - name: Cleanup rclone remote
        if: always()
        run: |
          rclone config delete "${{ secrets.RCLONE_REMOTE_NAME && secrets.RCLONE_REMOTE_NAME || 'r2' }}" || true
        shell: bash
