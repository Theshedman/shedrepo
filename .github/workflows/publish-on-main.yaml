name: Publish repo (build AUR from manifest, gen DB, upload)

on:
  push:
    branches: ["main"]

permissions:
  contents: read
  id-token: write

env:
  ARCH: x86_64
  REPO_OUT: output/repo
  ARTIFACT_OUT: output/artifacts
  # Make PGP-skip optional; set to "true" to skip PGP checks (not recommended)
  SKIP_PGP_CHECK: "false"
  # If true, allow builds to continue when validpgpkeys cannot be imported (use with caution)
  ALLOW_KEY_FAIL: "false"

jobs:
  build-and-publish:
    runs-on: ubuntu-latest
    env:
      # secrets injected at runtime (kept as env here)
      GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
      R2_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
      R2_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
      R2_ACCOUNT_ID: ${{ secrets.R2_ACCOUNT_ID }}
      R2_BUCKET: ${{ secrets.R2_BUCKET }}
      RCLONE_REMOTE_NAME: ${{ secrets.RCLONE_REMOTE_NAME }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Prepare paths
        run: |
          mkdir -p "${GITHUB_WORKSPACE}/${REPO_OUT}/${ARCH}"
          mkdir -p "${GITHUB_WORKSPACE}/${ARTIFACT_OUT}"
          echo "Manifest (packages/aur/manifest.txt):"
          sed -n '1,200p' packages/aur/manifest.txt || true
        shell: bash

      - name: Import GPG private key (host, for signing repo DB)
        run: |
          if [[ -n "${GPG_PRIVATE_KEY:-}" ]]; then
            printf '%s\n' "${GPG_PRIVATE_KEY}" > /tmp/gpg_private.asc
            gpg --batch --import /tmp/gpg_private.asc || true
            shred -u /tmp/gpg_private.asc || rm -f /tmp/gpg_private.asc
            gpg --list-secret-keys --keyid-format LONG || true
          else
            echo "GPG_PRIVATE_KEY not provided; skipping host import."
          fi
        shell: bash

      - name: Ensure scripts are executable
        run: |
          chmod +x scripts/build-aur.sh || true
          chmod +x shedrepo/commands/*.sh || true
        shell: bash

      - name: Install Docker (if needed) and rclone
        run: |
          set -euo pipefail
          if command -v docker >/dev/null 2>&1; then
            echo "docker already installed: $(docker --version)"
          else
            curl -fsSL https://get.docker.com | sudo sh
            sudo usermod -aG docker $USER || true
          fi

          if command -v rclone >/dev/null 2>&1; then
            echo "rclone already installed: $(rclone --version)"
          else
            curl -fsSL https://rclone.org/install.sh | sudo bash
          fi
        shell: bash

      - name: Build AUR packages from manifest (serial)
        env:
          ARCH: ${{ env.ARCH }}
          SKIP_PGP_CHECK: ${{ env.SKIP_PGP_CHECK }}
          ALLOW_KEY_FAIL: ${{ env.ALLOW_KEY_FAIL }}
        run: |
          set -euo pipefail
          ART_DIR="${GITHUB_WORKSPACE}/${ARTIFACT_OUT}"
          MANIFEST="packages/aur/manifest.txt"
          mkdir -p "${ART_DIR}"

          if [[ ! -f "${MANIFEST}" ]]; then
            echo "No AUR manifest found at ${MANIFEST}; nothing to build."
            exit 0
          fi

          # helper: retry a command N times with sleep
          retry() {
            local n=0
            local max=${1:-3}; shift
            local delay=${1:-3}; shift
            until "$@"; do
              n=$((n+1))
              if [[ $n -ge $max ]]; then
                echo "[retry] giving up after $n attempts: $*"
                return 1
              fi
              echo "[retry] attempt $n/$max failed: $*; sleeping ${delay}s"
              sleep "$delay"
            done
            return 0
          }

          while IFS= read -r pkg || [ -n "$pkg" ]; do
            pkg="$(echo "$pkg" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"
            [[ -z "$pkg" ]] && continue
            echo "==> Building package: $pkg"

            # build inside container, pass PKG and ARTIFACT_OUT via env
            docker run --rm -v "${GITHUB_WORKSPACE}:/workspace" -w "/workspace" \
              --env "ARCH=${ARCH}" --env "PKG=${pkg}" --env "ARTIFACT_OUT=${ARTIFACT_OUT}" \
              archlinux:latest /bin/bash -lc "
                set -euo pipefail

                # create builder user if missing; ensure workspace ownership
                useradd -m -s /bin/bash builder || true
                chown -R builder:builder /workspace || true

                # initialize pacman keyring if needed
                pacman-key --init || true
                pacman-key --populate archlinux || true

                # update small set first, but avoid full dist-upgrade cost repeatedly; still try with retry
                retry() { local max=\${1:-3}; shift; local delay=\${1:-3}; local n=0; until \"\$@\"; do n=\$((n+1)); if [[ \$n -ge \$max ]]; then return 1; fi; sleep \$delay; done; }
                retry 3 5 pacman -Sy --noconfirm archlinux-keyring || true

                # install base build deps (no heavy -Syu here, keep container small/fresh)
                retry 3 5 pacman -Sy --noconfirm --needed base-devel git fakeroot gnupg curl pacman-contrib || true

                TMPDIR=\$(mktemp -d /tmp/aurbuild.XXXXXX)
                gitclone_ok=1
                for attempt in 1 2 3; do
                  git clone --depth 1 \"https://aur.archlinux.org/packages/\${PKG}.git\" \"\${TMPDIR}\" 2>/dev/null && gitclone_ok=0 && break || true
                  git clone --depth 1 \"https://aur.archlinux.org/\${PKG}.git\" \"\${TMPDIR}\" 2>/dev/null && gitclone_ok=0 && break || true
                  sleep 2
                done
                if [[ \$gitclone_ok -ne 0 ]] || [[ ! -d \"\${TMPDIR}\" ]]; then
                  echo \"[ERROR] Failed to clone AUR package: \${PKG}\" >&2
                  exit 3
                fi

                cd \"\${TMPDIR}\"

                # Extract depends & makedepends (multi-line arrays supported)
                depends_raw=\$(awk '/^depends=\\(/,/\\)/ {print}' PKGBUILD 2>/dev/null | sed 's/depends=(//; s/).*//; s/[\"'\\''`]//g' | tr '\\n' ' ' | xargs || true)
                makedeps_raw=\$(awk '/^makedepends=\\(/,/\\)/ {print}' PKGBUILD 2>/dev/null | sed 's/makedepends=(//; s/).*//; s/[\"'\\''`]//g' | tr '\\n' ' ' | xargs || true)
                validpgpkeys_raw=\$(awk '/^validpgpkeys=\\(/,/\\)/ {print}' PKGBUILD 2>/dev/null | sed 's/validpgpkeys=(//; s/).*//; s/[\"'\\''`]//g' | tr '\\n' ' ' | xargs || true)
                if [[ -z \"\${validpgpkeys_raw}\" ]]; then
                  validpgpkeys_raw=\$(grep -oP 'validpgpkeys=\\(\\K[^)]+' PKGBUILD 2>/dev/null | sed 's/[\"'\\''`]//g' | xargs || true)
                fi

                # Try to import validpgpkeys into root and builder; prefer keys.openpgp.org, fallback to keys.ubuntu/pgp.mit.edu
                import_key_for() {
                  local target_user=\$1; shift
                  local key=\$1
                  if [[ -z \"\$key\" ]]; then return 0; fi
                  echo \"[INFO] Importing key \$key for \$target_user\"
                  if [[ \"\$target_user\" == root ]]; then
                    gpg --batch --keyserver keys.openpgp.org --recv-keys \"\$key\" 2>/dev/null || \
                    gpg --batch --keyserver keyserver.ubuntu.com --recv-keys \"\$key\" 2>/dev/null || \
                    gpg --batch --keyserver pgp.mit.edu --recv-keys \"\$key\" 2>/dev/null || return 1
                  else
                    su -s /bin/bash builder -c \"gpg --batch --keyserver keys.openpgp.org --recv-keys '\${key}'\" 2>/dev/null || \
                    su -s /bin/bash builder -c \"gpg --batch --keyserver keyserver.ubuntu.com --recv-keys '\${key}'\" 2>/dev/null || \
                    su -s /bin/bash builder -c \"gpg --batch --keyserver pgp.mit.edu --recv-keys '\${key}'\" 2>/dev/null || return 1
                  fi
                  return 0
                }

                if [[ -n \"\${validpgpkeys_raw// }\" ]]; then
                  for k in \${validpgpkeys_raw}; do
                    if ! import_key_for root \"\$k\"; then
                      echo \"[WARN] failed to import key \$k for root\"
                    fi
                    if ! import_key_for builder \"\$k\"; then
                      echo \"[WARN] failed to import key \$k for builder\"
                    fi
                  done
                fi

                # Combine dependency lists
                all_deps_raw=\"\${depends_raw} \${makedeps_raw}\"
                deps_list=()
                if [[ -n \"\${all_deps_raw// }\" ]]; then
                  read -ra tokens <<< \"\$(echo \"\${all_deps_raw}\" | tr '\\n' ' ' | tr -s ' ' ' ')\"
                  for tok in \"\${tokens[@]}\"; do
                    tok=\${tok//\"/}
                    tok=\${tok//\'/}
                    tok=\${tok//\`/}
                    tok=\${tok%%[<>=:]*}
                    if [[ -n \"\$tok\" ]]; then deps_list+=(\"\$tok\"); fi
                  done
                  # dedupe preserving order
                  declare -A seen
                  uniq=()
                  for p in \"\${deps_list[@]}\"; do
                    if [[ -z \"\${seen[\$p]+_}\" ]]; then uniq+=(\"\$p\"); seen[\$p]=1; fi
                  done
                  deps_list=(\"\${uniq[@]}\")
                fi

                if [[ \${#deps_list[@]} -gt 0 ]]; then
                  echo \"[INFO] Installing deps for \${PKG}: \${deps_list[*]}\"
                  retry 3 pacman -Sy --noconfirm || true
                  if ! pacman -S --noconfirm --needed \"\${deps_list[@]}\"; then
                    echo \"[WARN] Some deps failed to install via pacman; continuing and hoping makedepends are AUR-only\"
                  fi
                else
                  echo \"[INFO] No deps detected for \${PKG}\"
                fi

                # Move source into workspace and run build as non-root builder
                cd /workspace
                BUILD_SRC_DIR=\"/workspace/.aur_src_\${PKG}\"
                rm -rf \"\${BUILD_SRC_DIR}\" || true
                mv \"\${TMPDIR}\" \"\${BUILD_SRC_DIR}\"
                chown -R builder:builder \"\${BUILD_SRC_DIR}\"
                chmod +x /workspace/scripts/build-aur.sh || true

                # Run build and capture logs (stdout/stderr) to artifact path
                LOG_FILE=\"/workspace/${ARTIFACT_OUT}/\${PKG}.build.log\"
                mkdir -p \"$(dirname "/workspace/${ARTIFACT_OUT}")\" || true

                # Allow skipping PGP checks if SKIP_PGP_CHECK env is set to "true"
                SKIP_FLAG=\"\"
                if [[ \"${SKIP_PGP_CHECK}\" == \"true\" ]]; then SKIP_FLAG='--skippgpcheck'; fi

                # Run as builder user; wrap and capture exit code
                su -s /bin/bash builder -c \"
                  cd /workspace
                  export MAKEPKG_OPTS='\$SKIP_FLAG'
                  /workspace/scripts/build-aur.sh '\${BUILD_SRC_DIR}' '/workspace/${ARTIFACT_OUT}' >'\${LOG_FILE}' 2>&1
                \" || {
                  echo \"[ERROR] build failed for \${PKG}; log at ${ARTIFACT_OUT}/\${PKG}.build.log\"
                  exit 5
                }

                echo \"[INFO] Build succeeded for \${PKG}\"
              "
            # if container returns non-zero, ci step would have failed above and workflow exits,
            # but we capture logs inside the container before failure and will upload them in next steps.
          done < "${MANIFEST}"
        shell: bash

      - name: Show artifacts
        run: |
          echo "Artifacts dir listing:"
          find "${GITHUB_WORKSPACE}/${ARTIFACT_OUT}" -maxdepth 3 -ls || true
        shell: bash

      - name: Upload per-package build logs as artifacts (if any)
        uses: actions/upload-artifact@v4
        with:
          name: aur-build-logs
          path: "${ARTIFACT_OUT}/*.build.log"
        continue-on-error: true

      - name: Move artifacts into repo output dir
        run: |
          mkdir -p "${GITHUB_WORKSPACE}/${REPO_OUT}/${ARCH}"
          find "${GITHUB_WORKSPACE}/${ARTIFACT_OUT}" -type f -name '*.pkg.*' -exec cp -v {} "${GITHUB_WORKSPACE}/${REPO_OUT}/${ARCH}/" \;
          find "${GITHUB_WORKSPACE}/${ARTIFACT_OUT}" -type f -name '*.pkg.*.sig' -exec cp -v {} "${GITHUB_WORKSPACE}/${REPO_OUT}/${ARCH}/" \; || true
          ls -la "${GITHUB_WORKSPACE}/${REPO_OUT}/${ARCH}" || true
        shell: bash

      - name: Set REPO_ROOT and ARCH for gen_db
        run: |
          echo "REPO_ROOT=${GITHUB_WORKSPACE}/${REPO_OUT}" >> $GITHUB_ENV
          echo "ARCH=${ARCH}" >> $GITHUB_ENV
        shell: bash

      - name: Regenerate DB (gen_db.sh)
        run: |
          ./shedrepo/commands/gen_db.sh
        shell: bash

      - name: Configure rclone remote for R2
        run: |
          RCLONE_REMOTE="${{ secrets.RCLONE_REMOTE_NAME && secrets.RCLONE_REMOTE_NAME || 'r2' }}"
          R2_ENDPOINT="https://${{ secrets.R2_ACCOUNT_ID }}.r2.cloudflarestorage.com"
          rclone config create "${RCLONE_REMOTE}" s3 \
            env_auth false \
            access_key_id "${{ secrets.R2_ACCESS_KEY_ID }}" \
            secret_access_key "${{ secrets.R2_SECRET_ACCESS_KEY }}" \
            endpoint "${R2_ENDPOINT}" \
            region auto || true
        shell: bash

      - name: Upload repo to R2
        run: |
          RCLONE_REMOTE="${{ secrets.RCLONE_REMOTE_NAME && secrets.RCLONE_REMOTE_NAME || 'r2' }}"
          TARGET="${RCLONE_REMOTE}:${{ secrets.R2_BUCKET }}/${ARCH}/"
          rclone sync --progress --create-empty-src-dirs --delete-after "${GITHUB_WORKSPACE}/${REPO_OUT}/${ARCH}/" "${TARGET}" || true
        shell: bash

      - name: Cleanup rclone remote
        if: always()
        run: |
          rclone config delete "${{ secrets.RCLONE_REMOTE_NAME && secrets.RCLONE_REMOTE_NAME || 'r2' }}" || true
        shell: bash
