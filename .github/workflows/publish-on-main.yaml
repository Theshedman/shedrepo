name: Publish repo (build AUR from manifest, gen DB, upload)

on:
  push:
    branches: ["main"]

permissions:
  contents: read
  id-token: write

env:
  ARCH: x86_64
  REPO_OUT: output/repo
  ARTIFACT_OUT: output/artifacts

jobs:
  build-and-publish:
    runs-on: ubuntu-latest
    env:
      GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Prepare paths
        run: |
          mkdir -p "${GITHUB_WORKSPACE}/${REPO_OUT}/${ARCH}"
          mkdir -p "${GITHUB_WORKSPACE}/${ARTIFACT_OUT}"
          ls -la packages/aur || true

      - name: Import GPG private key (for signing packages if needed)
        if: ${{ env.GPG_PRIVATE_KEY != '' }}
        run: |
          echo "${{ env.GPG_PRIVATE_KEY }}" > /tmp/gpg_private.asc
          gpg --batch --import /tmp/gpg_private.asc || true
          shred -u /tmp/gpg_private.asc || rm -f /tmp/gpg_private.asc
          gpg --list-secret-keys --keyid-format LONG
        shell: bash

      - name: Install Docker (if needed) and rclone
        run: |
          set -euo pipefail

          if command -v docker >/dev/null 2>&1; then
            echo "docker already installed: $(docker --version)"
          else
            echo "Installing docker using official convenience script"
            curl -fsSL https://get.docker.com | sudo sh
            sudo usermod -aG docker $USER || true
            echo "docker installed: $(docker --version || true)"
          fi

          if command -v rclone >/dev/null 2>&1; then
            echo "rclone already installed: $(rclone --version)"
          else
            echo "Installing rclone"
            curl -fsSL https://rclone.org/install.sh | sudo bash
            rclone --version
          fi
        shell: bash

      - name: Build AUR packages from manifest (serial, non-root inside container)
        env:
          # keep host ARCH available to container via --env as well
          ARCH: ${{ env.ARCH }}
        run: |
          set -euo pipefail

          ART_DIR="${GITHUB_WORKSPACE}/${ARTIFACT_OUT}"

          # Read manifest line-by-line
          while IFS= read -r pkg || [ -n "$pkg" ]; do
            # trim whitespace
            pkg="$(echo "$pkg" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"
            [[ -z "$pkg" ]] && continue
            echo "==> Building package: $pkg"

            # Run build inside an archlinux container as follows:
            # 1) create builder user BEFORE pacman runs to avoid /etc locking problems
            # 2) init pacman keyring & populate
            # 3) install base-devel and deps
            # 4) ensure script is executable and run as builder (non-root)
            docker run --rm -v "${GITHUB_WORKSPACE}:/workspace" -w "/workspace" \
              --env "ARCH=${ARCH}" archlinux:latest /bin/bash -lc "
                set -euo pipefail

                # create non-root builder user first to avoid /etc locking races
                useradd -m -s /bin/bash builder || true
                chown -R builder:builder /workspace || true

                # initialize and populate pacman keyring
                pacman-key --init
                pacman-key --populate archlinux

                # update keyring package (safe now)
                pacman -Sy --noconfirm archlinux-keyring || true

                # system upgrade and install build deps
                pacman -Syu --noconfirm || true
                pacman -Sy --noconfirm --needed base-devel git fakeroot gnupg curl pacman-contrib

                # ensure build script is executable in the container mount
                chmod +x /workspace/scripts/build-aur.sh || true

                # run build as non-root 'builder' user (no sudo)
                su -s /bin/bash builder -c \"
                  cd /workspace
                  /workspace/scripts/build-aur.sh '${pkg}' '/workspace/${ARTIFACT_OUT}'
                \"
              "
          done < packages/aur/manifest.txt
        shell: bash

      - name: Show artifacts
        run: |
          echo "Artifacts dir listing:"
          find "${GITHUB_WORKSPACE}/${ARTIFACT_OUT}" -maxdepth 3 -ls || true

      - name: Move artifacts into repo output dir
        run: |
          mkdir -p "${GITHUB_WORKSPACE}/${REPO_OUT}/${ARCH}"
          # copy all .pkg.* and optional .sig into repo arch dir (preserve names)
          find "${GITHUB_WORKSPACE}/${ARTIFACT_OUT}" -type f -name '*.pkg.*' -exec cp -v {} "${GITHUB_WORKSPACE}/${REPO_OUT}/${ARCH}/" \;
          # also copy signatures if present
          find "${GITHUB_WORKSPACE}/${ARTIFACT_OUT}" -type f -name '*.pkg.*.sig' -exec cp -v {} "${GITHUB_WORKSPACE}/${REPO_OUT}/${ARCH}/" \; || true
          ls -la "${GITHUB_WORKSPACE}/${REPO_OUT}/${ARCH}" || true
        shell: bash

      - name: Ensure shedrepo scripts executable
        run: chmod +x shedrepo/shedrepo/commands/*.sh
        shell: bash

      - name: Set REPO_ROOT env for gen_db
        run: |
          echo "REPO_ROOT=${GITHUB_WORKSPACE}/${REPO_OUT}" >> $GITHUB_ENV
          echo "ARCH=${ARCH}" >> $GITHUB_ENV
        shell: bash

      - name: Regenerate DB (gen_db.sh)
        run: |
          ./shedrepo/shedrepo/commands/gen_db.sh
        shell: bash

      - name: Configure rclone remote for R2
        run: |
          # choose remote name, default 'r2' if not set
          RCLONE_REMOTE="${{ secrets.RCLONE_REMOTE_NAME && secrets.RCLONE_REMOTE_NAME || 'r2' }}"
          R2_ENDPOINT="https://${{ secrets.R2_ACCOUNT_ID }}.r2.cloudflarestorage.com"
          rclone config create "${RCLONE_REMOTE}" s3 \
            env_auth false \
            access_key_id "${{ secrets.R2_ACCESS_KEY_ID }}" \
            secret_access_key "${{ secrets.R2_SECRET_ACCESS_KEY }}" \
            endpoint "${R2_ENDPOINT}" \
            region auto
          echo "rclone remote '${RCLONE_REMOTE}' configured"
        shell: bash

      - name: Upload repo to R2
        run: |
          RCLONE_REMOTE="${{ secrets.RCLONE_REMOTE_NAME && secrets.RCLONE_REMOTE_NAME || 'r2' }}"
          TARGET="${RCLONE_REMOTE}:${{ secrets.R2_BUCKET }}/${ARCH}/"
          rclone sync --progress --create-empty-src-dirs --delete-after "${GITHUB_WORKSPACE}/${REPO_OUT}/${ARCH}/" "${TARGET}"
          echo "Upload finished."
        shell: bash

      - name: Cleanup rclone remote
        if: always()
        run: |
          rclone config delete "${{ secrets.RCLONE_REMOTE_NAME && secrets.RCLONE_REMOTE_NAME || 'r2' }}" || true
        shell: bash
